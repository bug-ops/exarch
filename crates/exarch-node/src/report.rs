//! Node.js bindings for `ExtractionReport`.

use exarch_core::ExtractionReport as CoreReport;
use napi_derive::napi;

/// Report of an archive extraction operation.
///
/// Contains statistics and metadata about the extraction process.
#[napi(object)]
#[derive(Debug, Clone)]
pub struct ExtractionReport {
    /// Number of files successfully extracted.
    pub files_extracted: u32,
    /// Number of directories created.
    pub directories_created: u32,
    /// Number of symlinks created.
    pub symlinks_created: u32,
    /// Total bytes written to disk.
    pub bytes_written: i64,
    /// Extraction duration in milliseconds.
    pub duration_ms: i64,
    /// Number of files skipped due to security checks.
    pub files_skipped: u32,
    /// List of warning messages.
    pub warnings: Vec<String>,
}

impl From<CoreReport> for ExtractionReport {
    #[allow(clippy::cast_possible_truncation, clippy::cast_possible_wrap)]
    fn from(report: CoreReport) -> Self {
        // Use saturating conversions to prevent silent wraparound on overflow
        // This ensures audit trails remain accurate even for very large extractions
        Self {
            files_extracted: report.files_extracted.min(u32::MAX as usize) as u32,
            directories_created: report.directories_created.min(u32::MAX as usize) as u32,
            symlinks_created: report.symlinks_created.min(u32::MAX as usize) as u32,
            bytes_written: report.bytes_written.min(i64::MAX as u64) as i64,
            duration_ms: report.duration.as_millis().min(i64::MAX as u128) as i64,
            files_skipped: report.files_skipped.min(u32::MAX as usize) as u32,
            warnings: report.warnings,
        }
    }
}

/// Report of an archive creation operation.
///
/// Contains statistics and metadata about the creation process.
#[napi(object)]
#[derive(Debug, Clone)]
pub struct CreationReport {
    /// Number of files added to the archive.
    pub files_added: u32,
    /// Number of directories added to the archive.
    pub directories_added: u32,
    /// Number of symlinks added to the archive.
    pub symlinks_added: u32,
    /// Total bytes written to the archive (uncompressed).
    pub bytes_written: i64,
    /// Total bytes in the final archive (compressed).
    pub bytes_compressed: i64,
    /// Duration of the creation operation in milliseconds.
    pub duration_ms: i64,
    /// Number of files skipped (due to filters or errors).
    pub files_skipped: u32,
    /// Warnings generated during creation.
    pub warnings: Vec<String>,
}

impl From<exarch_core::creation::CreationReport> for CreationReport {
    #[allow(clippy::cast_possible_truncation, clippy::cast_possible_wrap)]
    fn from(report: exarch_core::creation::CreationReport) -> Self {
        Self {
            files_added: report.files_added.min(u32::MAX as usize) as u32,
            directories_added: report.directories_added.min(u32::MAX as usize) as u32,
            symlinks_added: report.symlinks_added.min(u32::MAX as usize) as u32,
            bytes_written: report.bytes_written.min(i64::MAX as u64) as i64,
            bytes_compressed: report.bytes_compressed.min(i64::MAX as u64) as i64,
            duration_ms: report.duration.as_millis().min(i64::MAX as u128) as i64,
            files_skipped: report.files_skipped.min(u32::MAX as usize) as u32,
            warnings: report.warnings,
        }
    }
}

/// Complete manifest of archive contents.
///
/// Generated by `listArchive()`, contains metadata about all entries
/// without extracting them to disk.
#[napi(object)]
#[derive(Debug, Clone)]
pub struct ArchiveManifest {
    /// All entries in the archive (files, dirs, symlinks, hardlinks).
    pub entries: Vec<ArchiveEntry>,
    /// Total number of entries.
    pub total_entries: u32,
    /// Total uncompressed size in bytes.
    pub total_size: i64,
    /// Archive format (e.g., `TarGz`, `Zip`).
    pub format: String,
}

impl From<exarch_core::inspection::ArchiveManifest> for ArchiveManifest {
    #[allow(clippy::cast_possible_truncation, clippy::cast_possible_wrap)]
    fn from(manifest: exarch_core::inspection::ArchiveManifest) -> Self {
        Self {
            entries: manifest
                .entries
                .into_iter()
                .map(ArchiveEntry::from)
                .collect(),
            total_entries: manifest.total_entries.min(u32::MAX as usize) as u32,
            total_size: manifest.total_size.min(i64::MAX as u64) as i64,
            format: format!("{:?}", manifest.format),
        }
    }
}

/// Single entry in archive manifest.
///
/// Contains metadata about a file, directory, symlink, or hardlink
/// without extracting it to disk.
#[napi(object)]
#[derive(Debug, Clone)]
pub struct ArchiveEntry {
    /// Entry path (relative, as stored in archive).
    pub path: String,
    /// Entry type ("File", "Directory", "Symlink", "Hardlink").
    pub entry_type: String,
    /// Uncompressed size in bytes (0 for directories).
    pub size: i64,
    /// Compressed size in bytes (if available, ZIP only).
    pub compressed_size: Option<i64>,
    /// File permissions (Unix mode).
    pub mode: Option<u32>,
    /// Modification time (milliseconds since Unix epoch).
    pub modified: Option<i64>,
    /// Symlink target (if `entry_type` is "Symlink").
    pub symlink_target: Option<String>,
    /// Hardlink target (if `entry_type` is "Hardlink").
    pub hardlink_target: Option<String>,
}

impl From<exarch_core::inspection::ArchiveEntry> for ArchiveEntry {
    #[allow(clippy::cast_possible_truncation, clippy::cast_possible_wrap)]
    fn from(entry: exarch_core::inspection::ArchiveEntry) -> Self {
        Self {
            path: entry.path.to_string_lossy().into_owned(),
            entry_type: entry.entry_type.to_string(),
            size: entry.size.min(i64::MAX as u64) as i64,
            compressed_size: entry.compressed_size.map(|s| s.min(i64::MAX as u64) as i64),
            mode: entry.mode,
            modified: entry.modified.and_then(|t| {
                t.duration_since(std::time::UNIX_EPOCH)
                    .ok()
                    .map(|d| d.as_millis().min(i64::MAX as u128) as i64)
            }),
            symlink_target: entry
                .symlink_target
                .map(|p| p.to_string_lossy().into_owned()),
            hardlink_target: entry
                .hardlink_target
                .map(|p| p.to_string_lossy().into_owned()),
        }
    }
}

/// Result of archive verification.
///
/// Generated by `verifyArchive()`, contains security and integrity checks
/// performed without extracting files to disk.
#[napi(object)]
#[derive(Debug, Clone)]
pub struct VerificationReport {
    /// Overall verification status ("Pass", "Fail", "Warning").
    pub status: String,
    /// Integrity check result ("Pass", "Fail", "Warning", "Skipped").
    pub integrity_status: String,
    /// Security check result ("Pass", "Fail", "Warning", "Skipped").
    pub security_status: String,
    /// List of all issues found (sorted by severity).
    pub issues: Vec<VerificationIssue>,
    /// Total entries scanned.
    pub total_entries: u32,
    /// Entries flagged as suspicious.
    pub suspicious_entries: u32,
    /// Total uncompressed size.
    pub total_size: i64,
    /// Archive format (e.g., `TarGz`, `Zip`).
    pub format: String,
}

impl From<exarch_core::inspection::VerificationReport> for VerificationReport {
    #[allow(clippy::cast_possible_truncation, clippy::cast_possible_wrap)]
    fn from(report: exarch_core::inspection::VerificationReport) -> Self {
        Self {
            status: report.status.to_string(),
            integrity_status: report.integrity_status.to_string(),
            security_status: report.security_status.to_string(),
            issues: report
                .issues
                .into_iter()
                .map(VerificationIssue::from)
                .collect(),
            total_entries: report.total_entries.min(u32::MAX as usize) as u32,
            suspicious_entries: report.suspicious_entries.min(u32::MAX as usize) as u32,
            total_size: report.total_size.min(i64::MAX as u64) as i64,
            format: format!("{:?}", report.format),
        }
    }
}

/// Single verification issue.
#[napi(object)]
#[derive(Debug, Clone)]
pub struct VerificationIssue {
    /// Issue severity level ("Critical", "High", "Medium", "Low", "Info").
    pub severity: String,
    /// Issue category (`PathTraversal`, `SymlinkEscape`, etc.).
    pub category: String,
    /// Entry path that triggered issue (if applicable).
    pub entry_path: Option<String>,
    /// Human-readable description.
    pub message: String,
    /// Optional context (compression ratio, target path, etc.).
    pub context: Option<String>,
}

impl From<exarch_core::inspection::VerificationIssue> for VerificationIssue {
    fn from(issue: exarch_core::inspection::VerificationIssue) -> Self {
        Self {
            severity: issue.severity.to_string(),
            category: issue.category.to_string(),
            entry_path: issue.entry_path.map(|p| p.to_string_lossy().into_owned()),
            message: issue.message,
            context: issue.context,
        }
    }
}

#[cfg(test)]
#[allow(clippy::unwrap_used, clippy::expect_used)]
mod tests {
    use super::*;
    use std::time::Duration;

    #[test]
    fn test_extraction_report_conversion() {
        let mut core_report = CoreReport::new();
        core_report.files_extracted = 10;
        core_report.directories_created = 5;
        core_report.symlinks_created = 2;
        core_report.bytes_written = 1024;
        core_report.duration = Duration::from_millis(500);
        core_report.files_skipped = 1;
        core_report.add_warning("Test warning".to_string());

        let report = ExtractionReport::from(core_report);

        assert_eq!(report.files_extracted, 10);
        assert_eq!(report.directories_created, 5);
        assert_eq!(report.symlinks_created, 2);
        assert_eq!(report.bytes_written, 1024);
        assert_eq!(report.duration_ms, 500);
        assert_eq!(report.files_skipped, 1);
        assert_eq!(report.warnings.len(), 1);
        assert_eq!(report.warnings[0], "Test warning");
    }

    #[test]
    fn test_extraction_report_zero_values() {
        let core_report = CoreReport::new();
        let report = ExtractionReport::from(core_report);

        assert_eq!(report.files_extracted, 0);
        assert_eq!(report.directories_created, 0);
        assert_eq!(report.symlinks_created, 0);
        assert_eq!(report.bytes_written, 0);
        assert_eq!(report.files_skipped, 0);
        assert_eq!(report.warnings.len(), 0);
    }

    #[test]
    fn test_extraction_report_large_values() {
        let mut core_report = CoreReport::new();
        core_report.files_extracted = 100_000;
        core_report.directories_created = 50_000;
        core_report.bytes_written = 10_000_000_000; // 10 GB
        core_report.duration = Duration::from_secs(3600); // 1 hour

        let report = ExtractionReport::from(core_report);

        assert_eq!(report.files_extracted, 100_000);
        assert_eq!(report.bytes_written, 10_000_000_000);
        assert_eq!(report.duration_ms, 3_600_000);
    }

    #[test]
    fn test_extraction_report_multiple_warnings() {
        let mut core_report = CoreReport::new();
        core_report.add_warning("Warning 1".to_string());
        core_report.add_warning("Warning 2".to_string());
        core_report.add_warning("Warning 3".to_string());

        let report = ExtractionReport::from(core_report);

        assert_eq!(report.warnings.len(), 3);
        assert_eq!(report.warnings[0], "Warning 1");
        assert_eq!(report.warnings[1], "Warning 2");
        assert_eq!(report.warnings[2], "Warning 3");
    }

    #[test]
    fn test_extraction_report_duration_hours() {
        let mut core_report = CoreReport::new();
        core_report.duration = Duration::from_secs(7200); // 2 hours

        let report = ExtractionReport::from(core_report);

        assert_eq!(
            report.duration_ms, 7_200_000,
            "2 hours should be 7,200,000 milliseconds"
        );
    }

    #[test]
    fn test_extraction_report_duration_zero() {
        let mut core_report = CoreReport::new();
        core_report.duration = Duration::from_secs(0);

        let report = ExtractionReport::from(core_report);

        assert_eq!(report.duration_ms, 0, "zero duration should be 0 ms");
    }

    #[test]
    fn test_extraction_report_duration_microseconds() {
        let mut core_report = CoreReport::new();
        core_report.duration = Duration::from_micros(1500); // 1.5 ms

        let report = ExtractionReport::from(core_report);

        assert_eq!(
            report.duration_ms, 1,
            "1500 microseconds should round to 1 millisecond"
        );
    }

    #[test]
    fn test_extraction_report_warnings_order_preserved() {
        let mut core_report = CoreReport::new();
        core_report.add_warning("First warning".to_string());
        core_report.add_warning("Second warning".to_string());
        core_report.add_warning("Third warning".to_string());

        let report = ExtractionReport::from(core_report);

        assert_eq!(report.warnings.len(), 3, "should have 3 warnings");
        assert_eq!(
            report.warnings[0], "First warning",
            "first warning should be at index 0"
        );
        assert_eq!(
            report.warnings[1], "Second warning",
            "second warning should be at index 1"
        );
        assert_eq!(
            report.warnings[2], "Third warning",
            "third warning should be at index 2"
        );
    }

    // CreationReport tests
    #[test]
    fn test_creation_report_conversion() {
        let mut core_report = exarch_core::creation::CreationReport::new();
        core_report.files_added = 10;
        core_report.directories_added = 5;
        core_report.symlinks_added = 2;
        core_report.bytes_written = 1024;
        core_report.bytes_compressed = 512;
        core_report.duration = std::time::Duration::from_millis(500);
        core_report.files_skipped = 1;
        core_report.add_warning("Test warning".to_string());

        let report = CreationReport::from(core_report);

        assert_eq!(report.files_added, 10);
        assert_eq!(report.directories_added, 5);
        assert_eq!(report.symlinks_added, 2);
        assert_eq!(report.bytes_written, 1024);
        assert_eq!(report.bytes_compressed, 512);
        assert_eq!(report.duration_ms, 500);
        assert_eq!(report.files_skipped, 1);
        assert_eq!(report.warnings.len(), 1);
        assert_eq!(report.warnings[0], "Test warning");
    }

    // ArchiveEntry tests
    #[test]
    fn test_archive_entry_conversion() {
        use std::path::PathBuf;
        use std::time::UNIX_EPOCH;

        let core_entry = exarch_core::inspection::ArchiveEntry {
            path: PathBuf::from("test/file.txt"),
            entry_type: exarch_core::inspection::ManifestEntryType::File,
            size: 1024,
            compressed_size: Some(512),
            mode: Some(0o644),
            modified: Some(UNIX_EPOCH + std::time::Duration::from_secs(1000)),
            symlink_target: None,
            hardlink_target: None,
        };

        let entry = ArchiveEntry::from(core_entry);

        assert_eq!(entry.path, "test/file.txt");
        assert_eq!(entry.entry_type, "File");
        assert_eq!(entry.size, 1024);
        assert_eq!(entry.compressed_size, Some(512));
        assert_eq!(entry.mode, Some(0o644));
        assert_eq!(entry.modified, Some(1_000_000));
        assert_eq!(entry.symlink_target, None);
        assert_eq!(entry.hardlink_target, None);
    }

    // ArchiveManifest tests
    #[test]
    fn test_archive_manifest_conversion() {
        use exarch_core::formats::detect::ArchiveType;

        let mut core_manifest = exarch_core::inspection::ArchiveManifest::new(ArchiveType::TarGz);
        core_manifest.total_entries = 10;
        core_manifest.total_size = 5000;

        let manifest = ArchiveManifest::from(core_manifest);

        assert_eq!(manifest.total_entries, 10);
        assert_eq!(manifest.total_size, 5000);
        assert!(manifest.format.contains("TarGz"));
    }

    // VerificationReport tests
    #[test]
    fn test_verification_report_conversion() {
        use exarch_core::formats::detect::ArchiveType;
        use exarch_core::inspection::CheckStatus;
        use exarch_core::inspection::VerificationStatus;

        let core_report = exarch_core::inspection::VerificationReport {
            status: VerificationStatus::Pass,
            integrity_status: CheckStatus::Pass,
            security_status: CheckStatus::Pass,
            issues: vec![],
            total_entries: 10,
            suspicious_entries: 0,
            total_size: 5000,
            format: ArchiveType::TarGz,
        };

        let report = VerificationReport::from(core_report);

        assert_eq!(report.status, "PASS");
        assert_eq!(report.integrity_status, "OK");
        assert_eq!(report.security_status, "OK");
        assert_eq!(report.total_entries, 10);
        assert_eq!(report.suspicious_entries, 0);
        assert_eq!(report.total_size, 5000);
    }

    // VerificationIssue tests
    #[test]
    fn test_verification_issue_conversion() {
        use exarch_core::inspection::IssueCategory;
        use exarch_core::inspection::IssueSeverity;
        use std::path::PathBuf;

        let core_issue = exarch_core::inspection::VerificationIssue {
            severity: IssueSeverity::Critical,
            category: IssueCategory::PathTraversal,
            entry_path: Some(PathBuf::from("../etc/passwd")),
            message: "Path traversal detected".to_string(),
            context: Some("Attempt to escape directory".to_string()),
        };

        let issue = VerificationIssue::from(core_issue);

        assert_eq!(issue.severity, "CRITICAL");
        assert_eq!(issue.category, "Path Traversal");
        assert_eq!(issue.entry_path, Some("../etc/passwd".to_string()));
        assert_eq!(issue.message, "Path traversal detected");
        assert_eq!(
            issue.context,
            Some("Attempt to escape directory".to_string())
        );
    }
}
